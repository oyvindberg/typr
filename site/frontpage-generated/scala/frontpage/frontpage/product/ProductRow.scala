/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package frontpage.frontpage.product

import anorm.Column
import anorm.RowParser
import anorm.Success
import frontpage.Text
import frontpage.customtypes.Defaulted
import frontpage.customtypes.TypoJsonb
import frontpage.customtypes.TypoLocalDateTime
import play.api.libs.json.JsObject
import play.api.libs.json.JsResult
import play.api.libs.json.JsValue
import play.api.libs.json.OWrites
import play.api.libs.json.Reads
import play.api.libs.json.Writes
import scala.collection.immutable.ListMap
import scala.util.Try

/** Table: frontpage.product
 * Primary key: id
 */
case class ProductRow(
  /** Default: gen_random_uuid() */
  id: ProductId,
  name: String,
  price: BigDecimal,
  /** Default: true */
  inStock: Option[Boolean],
  /** Default: 0 */
  quantity: Option[Int],
  lastRestocked: Option[TypoLocalDateTime],
  /** Default: now() */
  lastModified: Option[TypoLocalDateTime],
  /** Default: '{}'::text[] */
  tags: Option[Array[String]],
  /** Default: '{}'::integer[] */
  categories: Option[Array[Int]],
  /** Default: '{}'::numeric[] */
  prices: Option[Array[BigDecimal]],
  /** Default: '{}'::jsonb[] */
  attributes: Option[Array[TypoJsonb]]
) {
  def toUnsavedRow(
    id: Defaulted[ProductId],
    inStock: Defaulted[Option[Boolean]] = Defaulted.Provided(this.inStock),
    quantity: Defaulted[Option[Int]] = Defaulted.Provided(this.quantity),
    lastModified: Defaulted[Option[TypoLocalDateTime]] = Defaulted.Provided(this.lastModified),
    tags: Defaulted[Option[Array[String]]] = Defaulted.Provided(this.tags),
    categories: Defaulted[Option[Array[Int]]] = Defaulted.Provided(this.categories),
    prices: Defaulted[Option[Array[BigDecimal]]] = Defaulted.Provided(this.prices),
    attributes: Defaulted[Option[Array[TypoJsonb]]] = Defaulted.Provided(this.attributes)
  ): ProductRowUnsaved = {
    new ProductRowUnsaved(
      name,
      price,
      lastRestocked,
      id,
      inStock,
      quantity,
      lastModified,
      tags,
      categories,
      prices,
      attributes
    )
  }
}

object ProductRow {
  given pgText: Text[ProductRow] = {
    Text.instance[ProductRow]{ (row, sb) =>
      ProductId.pgText.unsafeEncode(row.id, sb)
      sb.append(Text.DELIMETER)
      Text.stringInstance.unsafeEncode(row.name, sb)
      sb.append(Text.DELIMETER)
      Text.bigDecimalInstance.unsafeEncode(row.price, sb)
      sb.append(Text.DELIMETER)
      Text.option(using Text.booleanInstance).unsafeEncode(row.inStock, sb)
      sb.append(Text.DELIMETER)
      Text.option(using Text.intInstance).unsafeEncode(row.quantity, sb)
      sb.append(Text.DELIMETER)
      Text.option(using TypoLocalDateTime.pgText).unsafeEncode(row.lastRestocked, sb)
      sb.append(Text.DELIMETER)
      Text.option(using TypoLocalDateTime.pgText).unsafeEncode(row.lastModified, sb)
      sb.append(Text.DELIMETER)
      Text.option(using Text[Array[String]]).unsafeEncode(row.tags, sb)
      sb.append(Text.DELIMETER)
      Text.option(using Text[Array[Int]]).unsafeEncode(row.categories, sb)
      sb.append(Text.DELIMETER)
      Text.option(using Text[Array[BigDecimal]]).unsafeEncode(row.prices, sb)
      sb.append(Text.DELIMETER)
      Text.option(using Text.iterableInstance[Array, TypoJsonb](using TypoJsonb.pgText, summon)).unsafeEncode(row.attributes, sb)
    }
  }

  given reads: Reads[ProductRow] = {
    Reads[ProductRow](json => JsResult.fromTry(
        Try(
          ProductRow(
            id = json.\("id").as(ProductId.reads),
            name = json.\("name").as(Reads.StringReads),
            price = json.\("price").as(Reads.bigDecReads),
            inStock = json.\("in_stock").toOption.map(_.as(Reads.BooleanReads)),
            quantity = json.\("quantity").toOption.map(_.as(Reads.IntReads)),
            lastRestocked = json.\("last_restocked").toOption.map(_.as(TypoLocalDateTime.reads)),
            lastModified = json.\("last_modified").toOption.map(_.as(TypoLocalDateTime.reads)),
            tags = json.\("tags").toOption.map(_.as(Reads.ArrayReads[String](using Reads.StringReads, implicitly))),
            categories = json.\("categories").toOption.map(_.as(Reads.ArrayReads[Int](using Reads.IntReads, implicitly))),
            prices = json.\("prices").toOption.map(_.as(Reads.ArrayReads[BigDecimal](using Reads.bigDecReads, implicitly))),
            attributes = json.\("attributes").toOption.map(_.as(Reads.ArrayReads[TypoJsonb](using TypoJsonb.reads, implicitly)))
          )
        )
      ),
    )
  }

  def rowParser(idx: Int): RowParser[ProductRow] = {
    RowParser[ProductRow] { row =>
      Success(
        ProductRow(
          id = row(idx + 0)(using ProductId.column),
          name = row(idx + 1)(using Column.columnToString),
          price = row(idx + 2)(using Column.columnToScalaBigDecimal),
          inStock = row(idx + 3)(using Column.columnToOption(using Column.columnToBoolean)),
          quantity = row(idx + 4)(using Column.columnToOption(using Column.columnToInt)),
          lastRestocked = row(idx + 5)(using Column.columnToOption(using TypoLocalDateTime.column)),
          lastModified = row(idx + 6)(using Column.columnToOption(using TypoLocalDateTime.column)),
          tags = row(idx + 7)(using Column.columnToOption(using Column.columnToArray[String](using Column.columnToString, implicitly))),
          categories = row(idx + 8)(using Column.columnToOption(using Column.columnToArray[Int](using Column.columnToInt, implicitly))),
          prices = row(idx + 9)(using Column.columnToOption(using Column.columnToArray[BigDecimal](using Column.columnToScalaBigDecimal, implicitly))),
          attributes = row(idx + 10)(using Column.columnToOption(using TypoJsonb.arrayColumn))
        )
      )
    }
  }

  given writes: OWrites[ProductRow] = {
    OWrites[ProductRow](o =>
      new JsObject(ListMap[String, JsValue](
        "id" -> ProductId.writes.writes(o.id),
        "name" -> Writes.StringWrites.writes(o.name),
        "price" -> Writes.BigDecimalWrites.writes(o.price),
        "in_stock" -> Writes.OptionWrites(using Writes.BooleanWrites).writes(o.inStock),
        "quantity" -> Writes.OptionWrites(using Writes.IntWrites).writes(o.quantity),
        "last_restocked" -> Writes.OptionWrites(using TypoLocalDateTime.writes).writes(o.lastRestocked),
        "last_modified" -> Writes.OptionWrites(using TypoLocalDateTime.writes).writes(o.lastModified),
        "tags" -> Writes.OptionWrites(using Writes.arrayWrites[String](using implicitly, Writes.StringWrites)).writes(o.tags),
        "categories" -> Writes.OptionWrites(using Writes.arrayWrites[Int](using implicitly, Writes.IntWrites)).writes(o.categories),
        "prices" -> Writes.OptionWrites(using Writes.arrayWrites[BigDecimal](using implicitly, Writes.BigDecimalWrites)).writes(o.prices),
        "attributes" -> Writes.OptionWrites(using Writes.arrayWrites[TypoJsonb](using implicitly, TypoJsonb.writes)).writes(o.attributes)
      ))
    )
  }
}