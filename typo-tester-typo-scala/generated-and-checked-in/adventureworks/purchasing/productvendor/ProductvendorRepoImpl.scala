/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.purchasing.productvendor

import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.production.product.ProductId
import adventureworks.production.unitmeasure.UnitmeasureId
import java.sql.Connection
import java.util.ArrayList
import java.util.HashMap
import java.util.Optional
import typo.dsl.DeleteBuilder
import typo.dsl.SelectBuilder
import typo.dsl.UpdateBuilder
import typo.runtime.Fragment
import typo.runtime.Fragment.Literal
import typo.runtime.PgTypes
import typo.runtime.streamingInsert
import typo.runtime.FragmentInterpolator.interpolate

class ProductvendorRepoImpl extends ProductvendorRepo {
  def delete: DeleteBuilder[ProductvendorFields, ProductvendorRow] = DeleteBuilder.of("purchasing.productvendor", ProductvendorFields.structure)

  def deleteById(compositeId: ProductvendorId)(using c: Connection): java.lang.Boolean = interpolate"""delete from "purchasing"."productvendor" where "productid" = ${ProductId.pgType.encode(compositeId.productid)} AND "businessentityid" = ${BusinessentityId.pgType.encode(compositeId.businessentityid)}""".update().runUnchecked(c) > 0

  def deleteByIds(compositeIds: Array[ProductvendorId])(using c: Connection): Integer = {
    val productid: Array[ProductId] = compositeIds.map(_.productid)
    val businessentityid: Array[BusinessentityId] = compositeIds.map(_.businessentityid)
    interpolate"""delete
    from "purchasing"."productvendor"
    where ("productid", "businessentityid")
    in (select unnest(${ProductId.pgTypeArray.encode(productid)}::int4[]), unnest(${BusinessentityId.pgTypeArray.encode(businessentityid)}::int4[]))
    """.update().runUnchecked(c)
  }

  def insert(unsaved: ProductvendorRow)(using c: Connection): ProductvendorRow = {
  interpolate"""insert into "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate")
    values (${ProductId.pgType.encode(unsaved.productid)}::int4, ${BusinessentityId.pgType.encode(unsaved.businessentityid)}::int4, ${PgTypes.int4.encode(unsaved.averageleadtime)}::int4, ${PgTypes.numeric.encode(unsaved.standardprice)}::numeric, ${PgTypes.numeric.opt().encode(unsaved.lastreceiptcost)}::numeric, ${TypoLocalDateTime.pgType.opt().encode(unsaved.lastreceiptdate)}::timestamp, ${PgTypes.int4.encode(unsaved.minorderqty)}::int4, ${PgTypes.int4.encode(unsaved.maxorderqty)}::int4, ${PgTypes.int4.opt().encode(unsaved.onorderqty)}::int4, ${UnitmeasureId.pgType.encode(unsaved.unitmeasurecode)}::bpchar, ${TypoLocalDateTime.pgType.encode(unsaved.modifieddate)}::timestamp)
    returning "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text
    """
    .updateReturning(ProductvendorRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  def insert(unsaved: ProductvendorRowUnsaved)(using c: Connection): ProductvendorRow = {
    val columns: java.util.List[Literal] = new ArrayList()
    val values: java.util.List[Fragment] = new ArrayList()
    columns.add(Fragment.lit(""""productid"""")): @scala.annotation.nowarn
    values.add(interpolate"${ProductId.pgType.encode(unsaved.productid)}::int4"): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""businessentityid"""")): @scala.annotation.nowarn
    values.add(interpolate"${BusinessentityId.pgType.encode(unsaved.businessentityid)}::int4"): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""averageleadtime"""")): @scala.annotation.nowarn
    values.add(interpolate"${PgTypes.int4.encode(unsaved.averageleadtime)}::int4"): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""standardprice"""")): @scala.annotation.nowarn
    values.add(interpolate"${PgTypes.numeric.encode(unsaved.standardprice)}::numeric"): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""lastreceiptcost"""")): @scala.annotation.nowarn
    values.add(interpolate"${PgTypes.numeric.opt().encode(unsaved.lastreceiptcost)}::numeric"): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""lastreceiptdate"""")): @scala.annotation.nowarn
    values.add(interpolate"${TypoLocalDateTime.pgType.opt().encode(unsaved.lastreceiptdate)}::timestamp"): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""minorderqty"""")): @scala.annotation.nowarn
    values.add(interpolate"${PgTypes.int4.encode(unsaved.minorderqty)}::int4"): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""maxorderqty"""")): @scala.annotation.nowarn
    values.add(interpolate"${PgTypes.int4.encode(unsaved.maxorderqty)}::int4"): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""onorderqty"""")): @scala.annotation.nowarn
    values.add(interpolate"${PgTypes.int4.opt().encode(unsaved.onorderqty)}::int4"): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""unitmeasurecode"""")): @scala.annotation.nowarn
    values.add(interpolate"${UnitmeasureId.pgType.encode(unsaved.unitmeasurecode)}::bpchar"): @scala.annotation.nowarn
    unsaved.modifieddate.visit(
      (),
      value => {
        columns.add(Fragment.lit(""""modifieddate"""")): @scala.annotation.nowarn;
        values.add(interpolate"${TypoLocalDateTime.pgType.encode(value)}::timestamp"): @scala.annotation.nowarn;
      }
    );
    val q: Fragment = {
      interpolate"""insert into "purchasing"."productvendor"(${Fragment.comma(columns)})
      values (${Fragment.comma(values)})
      returning "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text
      """
    }
    q.updateReturning(ProductvendorRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  def insertStreaming(
    unsaved: java.util.Iterator[ProductvendorRow],
    batchSize: Integer = 10000
  )(using c: Connection): java.lang.Long = streamingInsert.insertUnchecked(s"""COPY "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate") FROM STDIN""", batchSize, unsaved, c, ProductvendorRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  def insertUnsavedStreaming(
    unsaved: java.util.Iterator[ProductvendorRowUnsaved],
    batchSize: Integer = 10000
  )(using c: Connection): java.lang.Long = streamingInsert.insertUnchecked(s"""COPY "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')""", batchSize, unsaved, c, ProductvendorRowUnsaved.pgText)

  def select: SelectBuilder[ProductvendorFields, ProductvendorRow] = SelectBuilder.of("purchasing.productvendor", ProductvendorFields.structure, ProductvendorRow.`_rowParser`)

  def selectAll(using c: Connection): java.util.List[ProductvendorRow] = {
    interpolate"""select "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text
    from "purchasing"."productvendor"
    """.as(ProductvendorRow.`_rowParser`.all()).runUnchecked(c)
  }

  def selectById(compositeId: ProductvendorId)(using c: Connection): Optional[ProductvendorRow] = {
    interpolate"""select "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text
    from "purchasing"."productvendor"
    where "productid" = ${ProductId.pgType.encode(compositeId.productid)} AND "businessentityid" = ${BusinessentityId.pgType.encode(compositeId.businessentityid)}""".as(ProductvendorRow.`_rowParser`.first()).runUnchecked(c)
  }

  def selectByIds(compositeIds: Array[ProductvendorId])(using c: Connection): java.util.List[ProductvendorRow] = {
    val productid: Array[ProductId] = compositeIds.map(_.productid)
    val businessentityid: Array[BusinessentityId] = compositeIds.map(_.businessentityid)
    interpolate"""select "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text
    from "purchasing"."productvendor"
    where ("productid", "businessentityid")
    in (select unnest(${ProductId.pgTypeArray.encode(productid)}::int4[]), unnest(${BusinessentityId.pgTypeArray.encode(businessentityid)}::int4[]))
    """.as(ProductvendorRow.`_rowParser`.all()).runUnchecked(c)
  }

  def selectByIdsTracked(compositeIds: Array[ProductvendorId])(using c: Connection): java.util.Map[ProductvendorId, ProductvendorRow] = {
    val ret: java.util.Map[ProductvendorId, ProductvendorRow] = new HashMap()
    selectByIds(compositeIds)(using c).forEach(row => ret.put(row.compositeId, row): @scala.annotation.nowarn)
    ret
  }

  def update: UpdateBuilder[ProductvendorFields, ProductvendorRow] = UpdateBuilder.of("purchasing.productvendor", ProductvendorFields.structure, ProductvendorRow.`_rowParser`.all())

  def update(row: ProductvendorRow)(using c: Connection): java.lang.Boolean = {
    val compositeId: ProductvendorId = row.compositeId
    interpolate"""update "purchasing"."productvendor"
    set "averageleadtime" = ${PgTypes.int4.encode(row.averageleadtime)}::int4,
    "standardprice" = ${PgTypes.numeric.encode(row.standardprice)}::numeric,
    "lastreceiptcost" = ${PgTypes.numeric.opt().encode(row.lastreceiptcost)}::numeric,
    "lastreceiptdate" = ${TypoLocalDateTime.pgType.opt().encode(row.lastreceiptdate)}::timestamp,
    "minorderqty" = ${PgTypes.int4.encode(row.minorderqty)}::int4,
    "maxorderqty" = ${PgTypes.int4.encode(row.maxorderqty)}::int4,
    "onorderqty" = ${PgTypes.int4.opt().encode(row.onorderqty)}::int4,
    "unitmeasurecode" = ${UnitmeasureId.pgType.encode(row.unitmeasurecode)}::bpchar,
    "modifieddate" = ${TypoLocalDateTime.pgType.encode(row.modifieddate)}::timestamp
    where "productid" = ${ProductId.pgType.encode(compositeId.productid)} AND "businessentityid" = ${BusinessentityId.pgType.encode(compositeId.businessentityid)}""".update().runUnchecked(c) > 0
  }

  def upsert(unsaved: ProductvendorRow)(using c: Connection): ProductvendorRow = {
  interpolate"""insert into "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate")
    values (${ProductId.pgType.encode(unsaved.productid)}::int4, ${BusinessentityId.pgType.encode(unsaved.businessentityid)}::int4, ${PgTypes.int4.encode(unsaved.averageleadtime)}::int4, ${PgTypes.numeric.encode(unsaved.standardprice)}::numeric, ${PgTypes.numeric.opt().encode(unsaved.lastreceiptcost)}::numeric, ${TypoLocalDateTime.pgType.opt().encode(unsaved.lastreceiptdate)}::timestamp, ${PgTypes.int4.encode(unsaved.minorderqty)}::int4, ${PgTypes.int4.encode(unsaved.maxorderqty)}::int4, ${PgTypes.int4.opt().encode(unsaved.onorderqty)}::int4, ${UnitmeasureId.pgType.encode(unsaved.unitmeasurecode)}::bpchar, ${TypoLocalDateTime.pgType.encode(unsaved.modifieddate)}::timestamp)
    on conflict ("productid", "businessentityid")
    do update set
      "averageleadtime" = EXCLUDED."averageleadtime",
    "standardprice" = EXCLUDED."standardprice",
    "lastreceiptcost" = EXCLUDED."lastreceiptcost",
    "lastreceiptdate" = EXCLUDED."lastreceiptdate",
    "minorderqty" = EXCLUDED."minorderqty",
    "maxorderqty" = EXCLUDED."maxorderqty",
    "onorderqty" = EXCLUDED."onorderqty",
    "unitmeasurecode" = EXCLUDED."unitmeasurecode",
    "modifieddate" = EXCLUDED."modifieddate"
    returning "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text
    """
    .updateReturning(ProductvendorRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  def upsertBatch(unsaved: java.util.Iterator[ProductvendorRow])(using c: Connection): java.util.List[ProductvendorRow] = {
    interpolate"""insert into "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate")
    values (?::int4, ?::int4, ?::int4, ?::numeric, ?::numeric, ?::timestamp, ?::int4, ?::int4, ?::int4, ?::bpchar, ?::timestamp)
    on conflict ("productid", "businessentityid")
    do update set
      "averageleadtime" = EXCLUDED."averageleadtime",
    "standardprice" = EXCLUDED."standardprice",
    "lastreceiptcost" = EXCLUDED."lastreceiptcost",
    "lastreceiptdate" = EXCLUDED."lastreceiptdate",
    "minorderqty" = EXCLUDED."minorderqty",
    "maxorderqty" = EXCLUDED."maxorderqty",
    "onorderqty" = EXCLUDED."onorderqty",
    "unitmeasurecode" = EXCLUDED."unitmeasurecode",
    "modifieddate" = EXCLUDED."modifieddate"
    returning "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text
    """
      .updateManyReturning(ProductvendorRow.`_rowParser`, unsaved)
      .runUnchecked(c)
  }

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  def upsertStreaming(
    unsaved: java.util.Iterator[ProductvendorRow],
    batchSize: Integer = 10000
  )(using c: Connection): Integer = {
    interpolate"""create temporary table productvendor_TEMP (like "purchasing"."productvendor") on commit drop""".update().runUnchecked(c): @scala.annotation.nowarn
    streamingInsert.insertUnchecked(s"""copy productvendor_TEMP("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate") from stdin""", batchSize, unsaved, c, ProductvendorRow.pgText): @scala.annotation.nowarn
    interpolate"""insert into "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate")
    select * from productvendor_TEMP
    on conflict ("productid", "businessentityid")
    do update set
      "averageleadtime" = EXCLUDED."averageleadtime",
    "standardprice" = EXCLUDED."standardprice",
    "lastreceiptcost" = EXCLUDED."lastreceiptcost",
    "lastreceiptdate" = EXCLUDED."lastreceiptdate",
    "minorderqty" = EXCLUDED."minorderqty",
    "maxorderqty" = EXCLUDED."maxorderqty",
    "onorderqty" = EXCLUDED."onorderqty",
    "unitmeasurecode" = EXCLUDED."unitmeasurecode",
    "modifieddate" = EXCLUDED."modifieddate"
    ;
    drop table productvendor_TEMP;""".update().runUnchecked(c)
  }
}