/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.product

import java.sql.Connection
import java.util.ArrayList
import java.util.HashMap
import java.util.Optional
import java.util.function.Function
import java.util.stream.Collectors
import typo.dsl.DeleteBuilder
import typo.dsl.DeleteBuilder.DeleteBuilderMock
import typo.dsl.DeleteParams
import typo.dsl.SelectBuilder
import typo.dsl.SelectBuilderMock
import typo.dsl.SelectParams
import typo.dsl.UpdateBuilder
import typo.dsl.UpdateBuilder.UpdateBuilderMock
import typo.dsl.UpdateParams

case class ProductRepoMock(
  toRow: ProductRowUnsaved => ProductRow,
  map: HashMap[ProductId, ProductRow] = new HashMap[ProductId, ProductRow]()
) extends ProductRepo {
  def delete: DeleteBuilder[ProductFields, ProductRow] = {
    new DeleteBuilderMock(
      ProductFields.structure,
      () => new ArrayList(map.values()),
      DeleteParams.empty(),
      row => row.productid,
      id => map.remove(id): @scala.annotation.nowarn
    )
  }

  def deleteById(productid: ProductId)(using c: Connection): java.lang.Boolean = Optional.ofNullable(map.remove(productid)).isPresent()

  def deleteByIds(productids: Array[ProductId])(using c: Connection): Integer = {
    var count = 0
    productids.foreach { id => if (Optional.ofNullable(map.remove(id)).isPresent()) {
      count = count + 1
    } }
    count
  }

  def insert(unsaved: ProductRow)(using c: Connection): ProductRow = {
    if (map.containsKey(unsaved.productid)) {
      throw new RuntimeException(s"id $unsaved.productid already exists")
    }
    map.put(unsaved.productid, unsaved): @scala.annotation.nowarn
    unsaved
  }

  def insert(unsaved: ProductRowUnsaved)(using c: Connection): ProductRow = insert(toRow(unsaved))(using c)

  def insertStreaming(
    unsaved: java.util.Iterator[ProductRow],
    batchSize: Integer = 10000
  )(using c: Connection): java.lang.Long = {
    var count = 0L
    while (unsaved.hasNext()) {
      val row = unsaved.next()
      map.put(row.productid, row): @scala.annotation.nowarn
      count = count + 1L
    }
    count
  }

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  def insertUnsavedStreaming(
    unsaved: java.util.Iterator[ProductRowUnsaved],
    batchSize: Integer = 10000
  )(using c: Connection): java.lang.Long = {
    var count = 0L
    while (unsaved.hasNext()) {
      val unsavedRow = unsaved.next()
      val row = toRow(unsavedRow)
      map.put(row.productid, row): @scala.annotation.nowarn
      count = count + 1L
    }
    count
  }

  def select: SelectBuilder[ProductFields, ProductRow] = new SelectBuilderMock(ProductFields.structure, () => new ArrayList(map.values()), SelectParams.empty())

  def selectAll(using c: Connection): java.util.List[ProductRow] = new ArrayList(map.values())

  def selectById(productid: ProductId)(using c: Connection): Optional[ProductRow] = Optional.ofNullable(map.get(productid))

  def selectByIds(productids: Array[ProductId])(using c: Connection): java.util.List[ProductRow] = {
    val result = new ArrayList[ProductRow]()
    productids.foreach { id => val opt = Optional.ofNullable(map.get(id))
    if (opt.isPresent()) result.add(opt.get()): @scala.annotation.nowarn }
    result
  }

  def selectByIdsTracked(productids: Array[ProductId])(using c: Connection): java.util.Map[ProductId, ProductRow] = selectByIds(productids)(using c).stream().collect(Collectors.toMap((row: adventureworks.production.product.ProductRow) => row.productid, Function.identity()))

  def update: UpdateBuilder[ProductFields, ProductRow] = {
    new UpdateBuilderMock(
      ProductFields.structure,
      () => new ArrayList(map.values()),
      UpdateParams.empty(),
      row => row
    )
  }

  def update(row: ProductRow)(using c: Connection): java.lang.Boolean = {
    val shouldUpdate = Optional.ofNullable(map.get(row.productid)).filter(oldRow => !oldRow.equals(row)).isPresent()
    if (shouldUpdate) {
      map.put(row.productid, row): @scala.annotation.nowarn
    }
    shouldUpdate
  }

  def upsert(unsaved: ProductRow)(using c: Connection): ProductRow = {
    map.put(unsaved.productid, unsaved): @scala.annotation.nowarn
    unsaved
  }

  def upsertBatch(unsaved: java.util.Iterator[ProductRow])(using c: Connection): java.util.List[ProductRow] = {
    val result = new ArrayList[ProductRow]()
    while (unsaved.hasNext()) {
      val row = unsaved.next()
      map.put(row.productid, row): @scala.annotation.nowarn
      result.add(row): @scala.annotation.nowarn
    }
    result
  }

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  def upsertStreaming(
    unsaved: java.util.Iterator[ProductRow],
    batchSize: Integer = 10000
  )(using c: Connection): Integer = {
    var count = 0
    while (unsaved.hasNext()) {
      val row = unsaved.next()
      map.put(row.productid, row): @scala.annotation.nowarn
      count = count + 1
    }
    count
  }
}