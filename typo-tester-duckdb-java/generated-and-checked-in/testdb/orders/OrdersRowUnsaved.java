/**
 * File has been automatically generated by `typo`.
 *
 * <p>IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.orders;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Optional;
import testdb.customtypes.Defaulted;
import testdb.customtypes.Defaulted.UseDefault;
import typo.runtime.DuckDbText;
import typo.runtime.DuckDbTypes;

/** This class corresponds to a row in table `orders` which has not been persisted yet */
public record OrdersRowUnsaved(
    @JsonProperty("order_id") OrdersId orderId,
    @JsonProperty("customer_id") Integer customerId,
    @JsonProperty("total_amount") Optional<BigDecimal> totalAmount,
    /** Default: current_date */
    @JsonProperty("order_date") Defaulted<LocalDate> orderDate,
    /** Default: 'pending' */
    Defaulted<Optional<String>> status) {
  public OrdersRowUnsaved(
      @JsonProperty("order_id") OrdersId orderId, @JsonProperty("customer_id") Integer customerId) {
    this(orderId, customerId, Optional.empty(), new UseDefault<>(), new UseDefault<>());
  }
  ;

  public OrdersRowUnsaved withOrderId(OrdersId orderId) {
    return new OrdersRowUnsaved(orderId, customerId, totalAmount, orderDate, status);
  }
  ;

  public OrdersRowUnsaved withCustomerId(Integer customerId) {
    return new OrdersRowUnsaved(orderId, customerId, totalAmount, orderDate, status);
  }
  ;

  public OrdersRowUnsaved withTotalAmount(Optional<BigDecimal> totalAmount) {
    return new OrdersRowUnsaved(orderId, customerId, totalAmount, orderDate, status);
  }
  ;

  /** Default: current_date */
  public OrdersRowUnsaved withOrderDate(Defaulted<LocalDate> orderDate) {
    return new OrdersRowUnsaved(orderId, customerId, totalAmount, orderDate, status);
  }
  ;

  /** Default: 'pending' */
  public OrdersRowUnsaved withStatus(Defaulted<Optional<String>> status) {
    return new OrdersRowUnsaved(orderId, customerId, totalAmount, orderDate, status);
  }
  ;

  public static DuckDbText<OrdersRowUnsaved> duckDbText =
      DuckDbText.instance(
          (row, sb) -> {
            OrdersId.duckDbType.duckDbText().unsafeEncode(row.orderId, sb);
            sb.append(DuckDbText.DELIMETER);
            DuckDbTypes.integer.duckDbText().unsafeEncode(row.customerId, sb);
            sb.append(DuckDbText.DELIMETER);
            DuckDbTypes.numeric.opt().duckDbText().unsafeEncode(row.totalAmount, sb);
            sb.append(DuckDbText.DELIMETER);
            Defaulted.duckDbText(DuckDbTypes.date.duckDbText()).unsafeEncode(row.orderDate, sb);
            sb.append(DuckDbText.DELIMETER);
            Defaulted.duckDbText(DuckDbTypes.varchar.opt().duckDbText())
                .unsafeEncode(row.status, sb);
          });

  public OrdersRow toRow(
      java.util.function.Supplier<LocalDate> orderDateDefault,
      java.util.function.Supplier<Optional<String>> statusDefault) {
    return new OrdersRow(
        orderId,
        customerId,
        orderDate.getOrElse(orderDateDefault),
        totalAmount,
        status.getOrElse(statusDefault));
  }
  ;
}
